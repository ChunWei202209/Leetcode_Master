func merge(nums1 []int, m int, nums2 []int, n int) {
    // i: 指向 nums1 有效元素的最後一個
    // j: 指向 nums2 的最後一個
    // p: 指向 nums1 最後一個位置（空位）
    i, j, p := m-1, n-1, m+n-1

    // 只要 nums1 和 nums2 都還有數字可以比
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] { // 情況 A：nums1 比較大
            nums1[p] = nums1[i] // 把 nums1 的最大值放到最後，然後 i 往前。
            i--
        } else { // nums2 比較大（或相等）
            nums1[p] = nums2[j] // 把 nums2 的最大值放到最後。
            j--
        }
        p-- // 宣告：這一輪已經用掉一個位置
    }

    // nums2 如果還有剩，一定是比較小的數，要補到前面（nums1 剩餘則不用動，因為已經在位置上了）
    for j >= 0 {
        nums1[p] = nums2[j]
        j--
        p--
    }
}

// 核心技巧：
// 左右指標倒序 / 正序填充

// 題目要點：
// 給你兩個有序整數陣列 nums1 和 nums2。
// nums1 有足夠的空間（大小為 m + n）來容納 nums2 的元素。
// 你必須在 nums1 原地 (In-place) 修改，不能回傳新陣列。

// 最優解法：三指針（從後往前） 
// 為什麼要從後往前？
// 因為 nums1 的後半部分是空的（補零的區域），
// 如果我們從前往後比，會需要移動 nums1 原有的元素導致 O(n^2) 複雜度）；
// 從後往前比，大的先放後面，完全不會覆蓋到還沒比過的資料。

// 解題步驟：
// 1. 初始化三個指標 (Pointers)
// 任何 slice / array：index 範圍永遠是 0 ~ len-1
//     a. i：指向 nums1 中最後一個「有效元素」的位置 (m - 1)。
//     b. j：指向 nums2 中最後一個元素的位置 (n - 1)。
//     c. p：指向 nums1 總體空間的「最末端」位置 (m + n - 1)，這是下一個最大值要存放的地方。
// 2. 逆向比較與填充 (Loop)
//   a. 當 i >= 0 且 j >= 0 時，執行迴圈：
//       比較大小：比較 nums1[i] 與 nums2[j]。
//   b. 填入較大值：
//       如果 nums1[i] > nums2[j]，將 nums1[i] 放入 nums1[p]，並將 i 減 1。
//       否則（nums2[j] 較大或相等），將 nums2[j] 放入 nums1[p]，並將 j 減 1。
//       移動存放位置：無論誰被放入，p 都要減 1。
// 3. 處理剩餘元素 (Edge Case)
//   迴圈結束後，可能會有其中一個陣列先耗盡：
//   a. 若 nums2 還有剩 (j >= 0)：
//       這代表 nums2 中剩下的數都比 nums1 原本最小的數還要小。
//       將 nums2 剩餘的元素直接依序填入 nums1 前面的剩餘位置。
//   b. 若 nums1 還有剩 (i >= 0)：
//       不需處理。因為這些元素原本就在 nums1 的正確位置上。

// 複雜度分析：
// 時間複雜度：O(m+n)。
// 我們只需要遍歷兩個陣列長度總和的一次。
// 空間複雜度：O(1)。
// 直接在 nums1 上原地修改，沒有使用額外空間。
